<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒæ­¥åŠŸèƒ½æµ‹è¯•</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .log {
            background: #f0f0f0;
            padding: 10px;
            margin: 5px 0;
            font-family: monospace;
        }

        .success {
            background: #d4edda;
            color: #155724;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
        }

        button {
            padding: 10px;
            margin: 5px;
        }

        input {
            padding: 5px;
            margin: 5px;
        }
    </style>
</head>

<body>
    <h1>åŒæ­¥åŠŸèƒ½æµ‹è¯•</h1>

    <div class="section">
        <h3>1. æµ‹è¯•ä»»åŠ¡åˆ›å»º</h3>
        <input type="text" id="taskTitle" placeholder="è¾“å…¥ä»»åŠ¡æ ‡é¢˜" value="åŒæ­¥æµ‹è¯•ä»»åŠ¡">
        <button onclick="testCreateTask()">åˆ›å»ºä»»åŠ¡</button>
        <button onclick="testGetTasks()">è·å–ä»»åŠ¡åˆ—è¡¨</button>
        <div id="taskLog"></div>
    </div>

    <div class="section">
        <h3>2. å®æ—¶åŒæ­¥æµ‹è¯•</h3>
        <button onclick="testRealtime()">æµ‹è¯•å®æ—¶åŒæ­¥</button>
        <button onclick="testPolling()">æµ‹è¯•è½®è¯¢åŒæ­¥</button>
        <div id="syncLog"></div>
    </div>

    <script>
        const SUPABASE_URL = 'https://rwiulfkdkbkztxfehuuz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ3aXVsZmtka2JrenR4ZmVodXV6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAwNTU4MTYsImV4cCI6MjA4NTYzMTgxNn0.mvjgJ5hHPBv3RP8u78IsA3t_i3FM72G80LnNN1q0hMI';

        let client = null;
        let taskCount = 0;

        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const time = new Date().toLocaleTimeString();
            const logDiv = document.createElement('div');
            logDiv.className = `log ${type}`;
            logDiv.innerHTML = `[${time}] ${message}`;
            element.appendChild(logDiv);
            element.scrollTop = element.scrollHeight;
        }

        function logTask(message, type = 'info') {
            log('taskLog', message, type);
        }

        function logSync(message, type = 'info') {
            log('syncLog', message, type);
        }

        async function initClient() {
            if (client) return client;

            try {
                logTask('æ­£åœ¨è¿æ¥Supabase...', 'info');
                client = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

                // æµ‹è¯•è¿æ¥
                const { data, error } = await client.from('tasks').select('count(*)').single();
                if (error) throw error;

                logTask('âœ… æ•°æ®åº“è¿æ¥æˆåŠŸ', 'success');
                return client;
            } catch (error) {
                logTask(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                throw error;
            }
        }

        async function testCreateTask() {
            try {
                await initClient();

                const title = document.getElementById('taskTitle').value || `æµ‹è¯•ä»»åŠ¡_${Date.now()}`;

                logTask(`åˆ›å»ºä»»åŠ¡: ${title}`, 'info');

                const taskData = {
                    title: title,
                    description: 'åŒæ­¥æµ‹è¯•ä»»åŠ¡',
                    priority: 'medium',
                    alarm_enabled: false,
                    completed: false,
                    notified_today: false,
                    user_id: `test_user_${Date.now()}`
                };

                const { data, error } = await client
                    .from('tasks')
                    .insert(taskData)
                    .select()
                    .single();

                if (error) throw error;

                taskCount++;
                logTask(`âœ… ä»»åŠ¡åˆ›å»ºæˆåŠŸ (ID: ${data.id})`, 'success');
                logTask(`æ ‡é¢˜: ${data.title}`, 'info');
                logTask(`ç”¨æˆ·: ${data.user_id}`, 'info');

            } catch (error) {
                logTask(`âŒ åˆ›å»ºå¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testGetTasks() {
            try {
                await initClient();

                logTask('è·å–ä»»åŠ¡åˆ—è¡¨...', 'info');

                const { data, error } = await client
                    .from('tasks')
                    .select('*')
                    .order('created_at', { ascending: false })
                    .limit(10);

                if (error) throw error;

                logTask(`âœ… è·å–æˆåŠŸï¼Œå…± ${data.length} ä¸ªä»»åŠ¡:`, 'success');
                data.forEach((task, index) => {
                    logTask(`${index + 1}. ${task.title} (ID: ${task.id}, ç”¨æˆ·: ${task.user_id.substring(0, 20)}...)`, 'info');
                });

            } catch (error) {
                logTask(`âŒ è·å–å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testRealtime() {
            try {
                await initClient();

                logSync('æµ‹è¯•å®æ—¶åŒæ­¥...', 'info');

                const channel = client
                    .channel('test-realtime')
                    .on('postgres_changes',
                        { event: '*', schema: 'public', table: 'tasks' },
                        (payload) => {
                            logSync(`ğŸ”„ å®æ—¶äº‹ä»¶: ${payload.eventType}`, 'success');
                            logSync(`æ•°æ®: ${JSON.stringify(payload.new || payload.old)}`, 'info');
                        }
                    )
                    .subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            logSync('âœ… å®æ—¶ç›‘å¬å·²å¯åŠ¨', 'success');
                            logSync('ç°åœ¨å¯ä»¥åˆ›å»ºä»»åŠ¡æµ‹è¯•åŒæ­¥', 'info');
                        } else {
                            logSync(`âŒ ç›‘å¬çŠ¶æ€: ${status}`, 'error');
                        }
                    });

                // 5ç§’åæµ‹è¯•åˆ›å»ºä»»åŠ¡
                setTimeout(() => {
                    logSync('åˆ›å»ºæµ‹è¯•ä»»åŠ¡...', 'info');
                    testCreateTask();
                }, 2000);

            } catch (error) {
                logSync(`âŒ å®æ—¶æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        let pollingInterval = null;

        function testPolling() {
            try {
                logSync('æµ‹è¯•è½®è¯¢åŒæ­¥...', 'info');

                let lastTaskCount = 0;
                let pollCount = 0;

                const checkTasks = async () => {
                    try {
                        await initClient();
                        pollCount++;

                        const { data, error } = await client
                            .from('tasks')
                            .select('*')
                            .order('created_at', { ascending: false });

                        if (error) throw error;

                        const currentCount = data.length;
                        if (currentCount > lastTaskCount) {
                            logSync(`ğŸ”„ è½®è¯¢æ£€æµ‹åˆ°æ–°ä»»åŠ¡ (${currentCount - lastTaskCount}ä¸ª)`, 'success');
                            lastTaskCount = currentCount;
                        } else if (pollCount % 5 === 0) {
                            logSync(`è½®è¯¢æ£€æŸ¥ #${pollCount}: å½“å‰ ${currentCount} ä¸ªä»»åŠ¡`, 'info');
                        }

                    } catch (error) {
                        logSync(`âŒ è½®è¯¢æ£€æŸ¥å¤±è´¥: ${error.message}`, 'error');
                    }
                };

                // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
                checkTasks();

                // æ¯3ç§’æ£€æŸ¥ä¸€æ¬¡
                pollingInterval = setInterval(checkTasks, 3000);
                logSync('âœ… è½®è¯¢åŒæ­¥å·²å¯åŠ¨ (é—´éš”3ç§’)', 'success');
                logSync('10ç§’ååœæ­¢è½®è¯¢', 'info');

                setTimeout(() => {
                    if (pollingInterval) {
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        logSync('è½®è¯¢åŒæ­¥å·²åœæ­¢', 'info');
                    }
                }, 10000);

            } catch (error) {
                logSync(`âŒ è½®è¯¢æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('load', async () => {
            logTask('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡æµ‹è¯•...', 'info');
            await initClient();
        });
    </script>
</body>

</html>